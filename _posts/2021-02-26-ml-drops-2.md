---
layout: post
title: Reuso em Lambda Container, melhorando sua performance
subtitle: ML Drops v2
tags: [aws, mlops, cloudformation, iaac, iac]
comments: true
draft: true
---

Fala Galera !

No Drops de hoje vamos falar sobre um assunto bem interessante, que, apesar de nao ser novo, muitas vezes passa desapercebido durante o desenvolvimento.

Quando falamos de arquiteturas serverless provavelmente uma das primeiras ferramentas que sempre aparecem como forte cadidata de uso são as Funções [Lambda](https://aws.amazon.com/pt/lambda/).

Devido ao grande poder de paralelismo, escalonamento e também alta disponibilidade as funções `Lambda` sempre enchem os olhos quando estamos codando nossa aplicação/modelo.

Ainda assim com tantos benefícios, podemos(e vamos) mostrar uma alternativa de ganho de performance durante as execuções das funções `Lambda`.

## Instanciamento e Spawn

Quando executamos uma função `Lambda` pedimos de forma explicita para que a AWS nos disponibilize uma infraestrutura e também um container que será responsável pela execução da função.

Como falamos anteriormente, um dos benefícios de uma função `Lambda` é o seu poder de escalabilidade, então, podemos assumir que caso simulássemos um ambiente de múltiplas requisições a mesma função `Lambda`, diversas cópias/containers da mesma seriam instanciadas utilizando a infraestrutura da AWS.


<p style="text-align: center"><img src="https://i.imgur.com/YIINDjE.png"></p>

É comum possuirmos conexões a Bancos de Dados(RDS), S3, SQS e outros serviços dentro de uma função lambda. Tais conexões aumentam o tempo de `runtime` das nossas funções, uma vez que as mesmas tem como objetivo fornecer uma experiência `stateful`.

Com isso, ao executarmos uma função `lambda` pela primeira vez  com os requisitos supracitados, ou então, executarmos a mesma depois de um período de inatividade, nos deparamos com o que a AWS chama de `cold start`.

## Cold Start e Container Reuse

Vamos as etapas do processo de `cold start` :


* Primeiro, Download de dependências Instanciamento/Download do código .
* Segundo, Inicia-se o container.
* Terceiro, o `runtime` de nossa função é inicializado.
* Quarto, tempo de inicialização do código fonte.
  
O fluxo acima sempre irá ocorrer, porém, a medida que as funções são executadas de forma escalonada e paralelizada a AWS prioriza a otimização dos seus recursos.

Ou seja, porque não reutilizarmos containers já instanciados para a execução de nossa função `Lambda` ?

E é **exatamente durante esta otimização** que a reutilização de containers mostra a que veio.

Quando reutilizamos containers já instanciados podemos tirar proveito do `Quarto` passo do processo de `cold start`, esta etapa também é conhecida como `warm start`.
  
O `warm start` pode ser otimizado diretamente no código fonte de nossa função `lambda`, essa otimização nos garante que as conexões/integrações que ocorrem durante o processamento serão reutilizadas, sem a necessidade de criação de novas instancias Exemplo: Load de .pkl's e conexões a Bancos de Dados.

Isso significa que, caso as conexões/integrações externas estejam **fora do método handler** as mesmas serão **reutilizadas** e não instanciadas novamente.

Com esta modificação, garantimos uma redução no tempo de execução da nossa função sempre que o processo de **reutilização de containers** esteja acontecendo.



<p style="text-align: center"><img src="https://i.imgur.com/OZliAry.jpg"></p>


## Bora pro Código

